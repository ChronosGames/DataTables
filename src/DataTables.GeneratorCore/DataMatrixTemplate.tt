<#@ template debug="false" hostspecific="false" linePragmas="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
// <auto-generated />
#pragma warning disable CS0105
#pragma warning disable CS8618 // Non-nullable field must contain a non-null value when exiting constructor. Consider adding the 'required' modifier or declaring as nullable.
#pragma warning disable CS8602 // Dereference of a possibly null reference.
using System;
using System.IO;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using DataTables;

#nullable enable

<# if (!string.IsNullOrEmpty(GenerationContext.Namespace)) { #>
namespace <#= GenerationContext.Namespace #>
{
<# } #>

public sealed partial class DT<#= GenerationContext.ClassName #> : DataMatrixBase<<#= BuildTypeString(kKey1) #>, <#= BuildTypeString(kKey2) #>, <#= BuildTypeString(kValue) #>>
{
    <#= string.IsNullOrEmpty(GenerationContext.MatrixDefaultValue) ? string.Empty : "protected override " + BuildTypeString(kValue) + " DefaultValue => " + BuildTypeValueString(kValue, GenerationContext.MatrixDefaultValue) + ";" + Environment.NewLine #>
    public DT<#= GenerationContext.ClassName #>(string name, int capacity) : base(name, capacity)
    { }

    public override bool ParseDataRow(int index, BinaryReader reader)
    {
        <#= BuildTypeString(kKey1) #> <#= kKey1 #>;
        <#= BuildDeserializeMethodString(kKey1) #>

        <#= BuildTypeString(kKey2) #> <#= kKey2 #>;
        <#= BuildDeserializeMethodString(kKey2) #>

        <#= BuildTypeString(kValue) #> <#= kValue #>;
        <#= BuildDeserializeMethodString(kValue) #>

        SetDataRow(index, <#= kKey1 #>, <#= kKey2 #>, <#= kValue #>);
        return true;
    }

    #region Instance API

    /// <summary>
    /// 根据Key1和Key2获取数据值 (实例方法)
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public <#= BuildTypeString(kValue) #>? GetDataRow(<#= BuildTypeString(kKey1) #> key1, <#= BuildTypeString(kKey2) #> key2)
    {
        return Get(key1, key2);
    }

    /// <summary>
    /// 根据Key1和Key2获取数据值，如果不存在则返回默认值 (实例方法)
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public <#= BuildTypeString(kValue) #> GetDataRowOrDefault(<#= BuildTypeString(kKey1) #> key1, <#= BuildTypeString(kKey2) #> key2)
    {
        var result = Get(key1, key2);
        return result != null ? result : DefaultValue;
    }

    #endregion

    #region Static API

    /// <summary>
    /// 获取数据矩阵实例 - 便于访问基类方法 (静态方法)
    /// </summary>
    public static DT<#= GenerationContext.ClassName #> Table
    {
        get
        {
            var table = DataTableManager.GetDataTableInternal<DT<#= GenerationContext.ClassName #>>();
            if (table == null)
            {
                throw new InvalidOperationException("DT<#= GenerationContext.ClassName #> not loaded. Call DataTableManager.CreateDataTable<DT<#= GenerationContext.ClassName #>>() first.");
            }
            return table;
        }
    }

    /// <summary>
    /// 安全获取数据矩阵实例 - 返回null如果未加载 (静态方法)
    /// </summary>
    public static DT<#= GenerationContext.ClassName #>? TableOrNull => DataTableManager.GetDataTableInternal<DT<#= GenerationContext.ClassName #>>();

    /// <summary>
    /// 检查数据矩阵是否已加载 (静态方法)
    /// </summary>
    public static bool IsLoaded => DataTableManager.IsLoaded<DT<#= GenerationContext.ClassName #>>();

    /// <summary>
    /// 根据Key1和Key2获取数据值 (静态方法)
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static <#= BuildTypeString(kValue) #>? GetRow(<#= BuildTypeString(kKey1) #> key1, <#= BuildTypeString(kKey2) #> key2)
    {
        var table = DataTableManager.GetDataTableInternal<DT<#= GenerationContext.ClassName #>>();
        return table?.Get(key1, key2);
    }

    /// <summary>
    /// 根据Key1和Key2获取数据值，如果不存在则返回默认值 (静态方法)
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static <#= BuildTypeString(kValue) #> GetRowOrDefault(<#= BuildTypeString(kKey1) #> key1, <#= BuildTypeString(kKey2) #> key2)
    {
        var table = DataTableManager.GetDataTableInternal<DT<#= GenerationContext.ClassName #>>();
        if (table != null)
        {
            var result = table.Get(key1, key2);
            return result != null ? result : table.DefaultValue;
        }
        return default(<#= BuildTypeString(kValue) #>);
    }

    #endregion

    #region MatrixDataRow Support

    /// <summary>
    /// 创建数据行实例
    /// </summary>
    protected override MatrixDataRowBase<<#= BuildTypeString(kKey1) #>, <#= BuildTypeString(kKey2) #>, <#= BuildTypeString(kValue) #>> CreateDataRowInstance()
    {
        return new DR<#= GenerationContext.ClassName #>();
    }

    #endregion
}

/// <summary>
/// <#= GenerationContext.ClassName #> 的数据行类 - 包含RowKey、ColumnKey和Value
/// </summary>
public sealed class DR<#= GenerationContext.ClassName #> : MatrixDataRowBase<<#= BuildTypeString(kKey1) #>, <#= BuildTypeString(kKey2) #>, <#= BuildTypeString(kValue) #>>
{
    /// <summary>
    /// 构造函数
    /// </summary>
    public DR<#= GenerationContext.ClassName #>() : base()
    {
    }

    /// <summary>
    /// 构造函数
    /// </summary>
    /// <param name="rowKey">行键</param>
    /// <param name="columnKey">列键</param>
    /// <param name="value">值</param>
    public DR<#= GenerationContext.ClassName #>(<#= BuildTypeString(kKey1) #> rowKey, <#= BuildTypeString(kKey2) #> columnKey, <#= BuildTypeString(kValue) #> value) 
        : base(rowKey, columnKey, value)
    {
    }

    /// <summary>
    /// 从二进制读取器反序列化
    /// </summary>
    public override bool Deserialize(BinaryReader reader)
    {
        <#= BuildTypeString(kKey1) #> rowKey;
        <#= BuildDeserializeMethodString(kKey1).Replace(kKey1, "rowKey") #>

        <#= BuildTypeString(kKey2) #> columnKey;
        <#= BuildDeserializeMethodString(kKey2).Replace(kKey2, "columnKey") #>

        <#= BuildTypeString(kValue) #> value;
        <#= BuildDeserializeMethodString(kValue).Replace(kValue, "value") #>

        SetData(rowKey, columnKey, value);
        return true;
    }
}

<# if (!string.IsNullOrEmpty(GenerationContext.Namespace)) { #>
}
<# } #>
